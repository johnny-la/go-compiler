top_level_declarations{-> decl} = 
  {func_decl} cst_func_decl semicolon {-> New decl.func_decl_ast(cst_func_decl.func_decl)} |
  {declarations} declarations {-> declarations.decl}
  ;

declarations {-> decl} =
  {var_decl} cst_var_decl {-> New decl.var_decl_ast(cst_var_decl.var_decl)} |
  {type_decl} cst_type_decl {-> New decl.type_decl_ast(cst_type_decl.type_decl)}
  ;

//function declarations here
cst_func_decl{-> func_decl} = 
  {no_return} func cst_id l_paren multi_sig? r_paren cst_block 
  {-> New func_decl.no_return(cst_id.id_type, 
                           multi_sig.signature,
                           cst_block.stmt
        )} |
  {single_return} func [name]:cst_id l_paren multi_sig? r_paren cst_type cst_block 
  {-> New func_decl.single_return(name.id_type, 
                           multi_sig.signature,
                           cst_type.var_type,
                           cst_block.stmt
  )}
  ;

multi_sig {-> signature} = 
  {recurse} signature comma multi_sig {-> New signature.multiple_types(signature.signature, multi_sig.signature)} |
  {base} signature {-> signature.signature}
  ;

signature {-> signature} = 
  {recurse} cst_id comma signature {-> New signature.many_id_to_type(cst_id.id_type, signature.signature)} |
  {base} cst_id cst_type{-> New signature.single_id_to_type(cst_id.id_type, cst_type.var_type)}
  ;


//type declaration and necessary subproductions here
cst_type_decl {-> type_decl} =
  {single_line} type_keyword type_top_level{-> type_top_level.type_decl} |
  {multi_line} type_keyword l_paren type_top_level* r_paren semicolon {-> New type_decl.multiline_list([type_top_level.type_decl])}
  ;

type_top_level {-> type_decl} = 
  {alias} type_aliasing semicolon {-> type_aliasing.type_decl} |
  {struct} type_struct_declaration {-> type_struct_declaration.type_decl}
  ;

type_aliasing {-> type_decl} = 
  {id_alias} cst_id cst_type {-> New type_decl.type_alias(cst_id.id_type, cst_type.var_type)}
  ;
  
type_struct_declaration {-> type_decl} = 
  cst_id struct l_brace type_with_one_or_more_ids* r_brace {-> New type_decl.struct_with_id(cst_id.id_type, 
  [type_with_one_or_more_ids.type_decl])}
  ;

type_with_one_or_more_ids {-> type_decl} = 
  {recurse} cst_id comma type_with_one_or_more_ids {-> New type_decl.type_with_many_ids(cst_id.id_type, type_with_one_or_more_ids.type_decl)} |
  {base} cst_id cst_type semicolon {-> New type_decl.type_alias(cst_id.id_type, cst_type.var_type)}
  ;

//variable declaration and necessary subproductions here
cst_var_decl {-> var_decl} =
  {cst_single_line_decl} var top_var_decl {-> top_var_decl.var_decl} |
  {cst_multi_line_decl} var l_paren top_var_decl* r_paren semicolon {-> New var_decl.multiline_list([top_var_decl.var_decl])}
  ;

top_var_decl {-> var_decl} = 
  {cst_miat} var_id_and_type semicolon {-> var_id_and_type.var_decl} |
  {cst_miae} var_id_and_exp_maybe_type semicolon {-> var_id_and_exp_maybe_type.var_decl}
  ;

var_id_and_type {-> var_decl} = 
  {miat_recurse} cst_id comma var_id_and_type {-> New var_decl.inline_list_no_exp(cst_id.id_type, var_id_and_type.var_decl)} |
  {miat_end} cst_id cst_type {-> New var_decl.var_with_type(cst_id.id_type, cst_type.var_type)}
  ;

var_id_and_exp_maybe_type {-> var_decl} = 
  {miae_recurse} cst_id [l]:comma var_id_and_exp_maybe_type [r]:comma cst_exp {-> New var_decl.inline_list_with_exp(cst_id.id_type, var_id_and_exp_maybe_type.var_decl, cst_exp.exp)} |
  {miae_end} cst_id equals cst_exp {-> New var_decl.var_with_only_exp(cst_id.id_type, cst_exp.exp)} |
  {mtae_end} cst_id cst_type equals cst_exp {-> New var_decl.var_with_type_and_exp(cst_id.id_type, cst_type.var_type, cst_exp.exp)};

//general type production for all declarations
cst_type {-> var_type} = 
  {cst_base_type} type {-> New var_type.base_type(type)}|
  {cst_slices} l_brack r_brack cst_type {-> New var_type.slice(cst_type.var_type)} | 
  {cst_arrays} l_brack int r_brack cst_type {-> New var_type.array(int, cst_type.var_type)}|
  {cst_structs} id {-> New var_type.struct(id)}
  ;
  
cst_id  {-> id_type} = 
  {id} id {-> New id_type.id(id)} |
  {type} type {-> New id_type.type(type)}
  ;


decl = 
  {func_decl_ast} func_decl |
  {var_decl_ast} var_decl |
  {type_decl_ast} type_decl
  ;

func_decl = 
  {no_return} id_type signature? [block]:stmt |
  {single_return} id_type signature? var_type [block]:stmt  |
  ;

signature = 
  {single_id_to_type} id_type var_type |
  {many_id_to_type} id_type signature |
  {multiple_types} [root]:signature [leaf]:signature
  ;

type_decl = 
  {type_alias} id_type var_type |
  {type_with_many_ids} id_type type_decl |
  {struct_with_id} id_type type_decl* |
  {multiline_list} type_decl*
  ;

var_decl = 
  {var_with_type} id_type var_type |
  {var_with_only_exp} id_type exp |
  {var_with_type_and_exp} id_type var_type exp |
  {inline_list_no_exp} id_type var_decl |
  {inline_list_with_exp} id_type var_decl exp |
  {multiline_list} var_decl*
  ;

var_type = 
  {base_type} type |
  {slice} var_type |
  {array} int var_type |
  {struct} id
  ;

id_type = 
  {id} id |
  {type} type
  ;

