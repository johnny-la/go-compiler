Package golite;

Helpers
  all_chars = [0..0xffff];
  all_chars_but_linefeed = [all_chars-10];
  all_chars_but_star_slash = [[all_chars-'*']-'/'];
  star_without_slash = '*' [all_chars - '/'];
  tab = 9;
  line_feed = 10;
  carriage_return = 13;
  space = ' ';
  digit = ['0'..'9'];
  positive_digit = ['1'..'9'];
  integer = '0' | (positive_digit digit*);
  float_decimal = '.' digit*;
  letter = ['a'..'z'] | ['A'..'Z'];
  string_symbols = letter | digit | ':' | ':' | '~' | '#' | '$' | '%' | '^' | '&' | '*' | '-' | '+' | '/' | '`' | ''' | '<' | '>' | '=' | '_' | '|' | ';' | ':' | '{' | '}' | '[' | ']' | '(' | ')' | space | '@' | '!' | '?' | '.' | ',';
  escape_single_quote = '\' ''';
  escape_double_quote = '\"';
  escape_sequences = '\a' | '\b' | '\f' | '\n' | '\r' | '\t' | '\v' | '\\' | escape_single_quote;
  oct_digit = ['0' .. '7'] ;
  hex_digit = digit | ['A' .. 'F'] | ['a' .. 'f'] ;
  single_quote = ''' ;
  double_quote = '"' ;
  back_quote = '`' ;
  not_end_of_line = [all_chars - [carriage_return + line_feed]] ;

Tokens
  if = 'if';
  else = 'else';
  break = 'break';
  return = 'return';
  case = 'case';
  chan = 'chan';
  const = 'const';
  continue = 'continue';
  default = 'default';
  defer = 'defer';
  fallthrough = 'fallthrough';
  for = 'for';
  func = 'func';
  go = 'go';
  goto = 'goto';
  var = 'var';
  import = 'import';
  interface = 'interface';
  map = 'map';
  package = 'package';
  range = 'range';
  select = 'select';
  struct = 'struct';
  switch = 'switch';
  op_equals = ('+' | '&' | '&^' | '-' | '|' | '*' | '^' | '/' | '<<' | '%' | '>>') '=';
  type = 'float64'|'rune'|'int'|'bool'|'string';
  type_keyword = 'type';
  plus = '+';
  minus = '-';
  star = '*';
  slash = '/';
  modulo = '%';
  ampersand = '&';
  pipe = '|';
  caret = '^';
  shift_left = '<<';
  shift_right = '>>';
  ampersand_caret = '&^';
  logical_and = '&&';
  logical_or = '||';
  left_arrow = '<-';
  plus_plus = '++';
  minus_minus = '--';
  equals_equals = '==';
  less = '<';
  greater = '>';
  equals = '=';
  exclamation = '!';
  exclamation_equals = '!=';
  less_equals = '<=';
  greater_equals = '>=';
  colon_equals = ':=';
  dot_dot_dot = '...';
  l_paren = '(';
  r_paren = ')';
  l_brack = '[';
  r_brack = ']';
  l_brace = '{';
  r_brace = '}';
  comma = ',';
  semicolon = ';';
  colon = ':';
  dot = '.';
  print = 'print';
  println = 'println';
  append = 'append';
  comment = '//' all_chars_but_linefeed*;
  block_comment = '/*' (all_chars_but_star_slash | '/*' | '/' | star_without_slash)* '*/';
  int = integer;
  oct = '0' oct_digit+ ;
  hex = '0' ['x' + 'X'] hex_digit+;
  float64_literal = digit* '.' digit* | '.' digit+ ;
  //float64 = 'float64';
  //bool = 'bool';
  //rune = 'rune';
  rune_literal = single_quote ([not_end_of_line - [single_quote + '\']] | escape_single_quote | escape_sequences) single_quote ;
  raw_string_lit = back_quote [all_chars - back_quote]* back_quote ;
  interpreted_string_literal = double_quote ([not_end_of_line - [double_quote + '\']] | escape_double_quote| escape_sequences)* double_quote ;
  id = (letter | '_')(letter | digit | '_')*;
  end_of_file = 26;
  eol = line_feed | carriage_return | carriage_return line_feed;
  blank = tab | space;

Ignored Tokens
  eol, blank, comment, block_comment;

Productions
cst_prog {-> program} =
  {prog} cst_package_decl top_level_declarations* {-> New program(cst_package_decl.package_decl, 
  [top_level_declarations.decl])}
  ; 

top_level_declarations{-> decl} = 
  {package_decl} cst_package_decl semicolon {-> New decl.pack_decl_ast(cst_package_decl.package_decl)} |
  {func_decl} cst_func_decl semicolon {-> New decl.func_decl_ast(cst_func_decl.func_decl)} |
  {declarations} declarations semicolon {-> declarations.decl}
  ;

cst_package_decl{-> package_decl} = 
  package cst_id semicolon {-> New package_decl(cst_id.id_type)}
  ;

declarations {-> decl} =
  {var_decl} cst_var_decl {-> New decl.var_decl_ast(cst_var_decl.var_decl)} |
  {type_decl} cst_type_decl {-> New decl.type_decl_ast(cst_type_decl.type_decl)}
  ;

//function declarations here
cst_func_decl{-> func_decl} = 
  {no_return} func cst_id l_paren multi_sig? r_paren cst_block 
  {-> New func_decl.no_return(cst_id.id_type, 
                           multi_sig.signature,
                           cst_block.stmt
        )} |
  {single_return} func [name]:cst_id l_paren multi_sig? r_paren cst_type cst_block 
  {-> New func_decl.single_return(name.id_type, 
                           multi_sig.signature,
                           cst_type.var_type,
                           cst_block.stmt
  )}
  ;

multi_sig {-> signature} = 
  {recurse} cst_id_list cst_type comma multi_sig {-> New signature.multiple_types([cst_id_list.id_type], cst_type.var_type, multi_sig.signature)} |//signature.signature, multi_sig.signature)} |
  {base} cst_id_list cst_type {-> New signature.single_type([cst_id_list.id_type], cst_type.var_type)}
  ;


//type declaration and necessary subproductions here
cst_type_decl {-> type_decl} =
  {single_line} type_keyword type_top_level{-> type_top_level.type_decl} |
  {multi_line} type_keyword l_paren type_top_level_eos* r_paren {-> New type_decl.multiline_list([type_top_level_eos.type_decl])}
  ;

type_top_level_eos {-> type_decl} =
  {type_top_level_eos} type_top_level cst_eos {-> type_top_level.type_decl};

type_top_level {-> type_decl} = 
  {alias} type_aliasing {-> type_aliasing.type_decl} |
  {struct} type_struct_declaration {-> type_struct_declaration.type_decl}
  ;

type_aliasing {-> type_decl} = 
  cst_id cst_type {-> New type_decl.type_alias(cst_id.id_type, cst_type.var_type)}
  ;
  
type_struct_declaration {-> type_decl} = 
  cst_id struct l_brace semicolon struct_or_list* r_brace {-> New type_decl.struct_with_id(cst_id.id_type, 
  [struct_or_list.type_decl])}
  ;

struct_array_list {-> exp*} =
  {end} struct_array {-> [struct_array.exp]} |
  {list} struct_array_list struct_array {-> [struct_array_list.exp, struct_array.exp]}
  ;

struct_array {-> exp} =
  {int} l_brack cst_int r_brack {-> cst_int.exp}
  ;

cst_int {-> exp} =
  {int} int {-> New exp.int(int)} |
  {oct} oct {-> New exp.oct(oct)} |
  {hex} hex {-> New exp.hex(hex)}
  ;

struct_or_list {-> type_decl} =
  {struct} type_struct_declaration semicolon {-> type_struct_declaration.type_decl} |
  {list} type_with_one_or_more_ids {-> type_with_one_or_more_ids.type_decl}
  ;

type_with_one_or_more_ids {-> type_decl} = 
  {list} cst_id_list cst_type semicolon {-> New type_decl.struct_var_decl([cst_id_list.id_type],cst_type.var_type)}
  //{recurse} cst_id comma type_with_one_or_more_ids {-> New type_decl.type_with_many_ids(cst_id.id_type, type_with_one_or_more_ids.type_decl)} |
  //{base} cst_id cst_type semicolon {-> New type_decl.type_alias(cst_id.id_type, cst_type.var_type)}
  ;

//variable declaration and necessary subproductions here
cst_var_decl {-> var_decl} =
  {cst_single_line_decl} var top_var_decl {-> top_var_decl.var_decl} |
  {cst_multi_line_decl} var l_paren top_var_decl_eos* r_paren {-> New var_decl.multiline_list([top_var_decl_eos.var_decl])}
  ;

top_var_decl_eos {-> var_decl} =
  {cst_decl_eos}  top_var_decl semicolon {-> top_var_decl.var_decl};

top_var_decl {-> var_decl} = 
  {cst_miat} var_id_and_type {-> var_id_and_type.var_decl} |
  {cst_miae} var_id_and_exp_maybe_type {-> var_id_and_exp_maybe_type.var_decl}
  ;

var_id_and_type {-> var_decl} = 
  {miat_recurse} cst_id comma var_id_and_type {-> New var_decl.inline_list_no_exp(cst_id.id_type, var_id_and_type.var_decl)} |
  {miat_end} cst_id cst_type {-> New var_decl.var_with_type(cst_id.id_type, cst_type.var_type)}
  ;

var_id_and_exp_maybe_type {-> var_decl} = 
  {miae_recurse} cst_id [l]:comma var_id_and_exp_maybe_type [r]:comma cst_exp {-> New var_decl.inline_list_with_exp(cst_id.id_type, var_id_and_exp_maybe_type.var_decl, cst_exp.exp)} |
  {miae_end} cst_id equals cst_exp {-> New var_decl.var_with_only_exp(cst_id.id_type, cst_exp.exp)} |
  {mtae_end} cst_id cst_type equals cst_exp {-> New var_decl.var_with_type_and_exp(cst_id.id_type, cst_type.var_type, cst_exp.exp)};

//general type production for all declarations
cst_type {-> var_type} = 
  {cst_base_type} type {-> New var_type.base_type(type)}|
  {cst_slices} l_brack r_brack cst_type {-> New var_type.slice(cst_type.var_type)} | 
  {cst_arrays} l_brack int r_brack cst_type {-> New var_type.array(int, cst_type.var_type)}|
  {cst_structs} id {-> New var_type.struct(id)}
  ;
  
cst_id_list {-> id_type*} =
  {id}   cst_id                   {-> [cst_id.id_type]} |
  {list} cst_id comma cst_id_list {-> [cst_id.id_type, cst_id_list.id_type]} 
  ;

cst_id {-> id_type} = 
  {id} id {-> New id_type.id(id)} |
  {type} type {-> New id_type.type(type)}
  ;

cst_stmt {-> stmt} =
  {cst_empty}      /*empty*/           {-> New stmt.empty()} |
  //{cst_func_call}  function_call       {-> New stmt.exp(function_call.exp)} |
  {cst_decl}       declarations        {-> New stmt.decl(declarations.decl)} |
  {cst_simple}     cst_simple_stmt     {-> cst_simple_stmt.stmt} |
  {cst_print}      print l_paren cst_exp_list? r_paren {-> New stmt.print([cst_exp_list.exp])} |
  {cst_println}    println l_paren cst_exp_list? r_paren {-> New stmt.println([cst_exp_list.exp])} |
  {cst_return}     return cst_exp?  {-> New stmt.return(cst_exp.exp)} |
  {cst_if}         cst_if_stmt     {-> cst_if_stmt.stmt} |
  {cst_switch}     cst_switch_stmt {-> cst_switch_stmt.stmt} |
  {cst_for}        for cst_for_condition cst_block {-> New stmt.for(cst_for_condition.exp, cst_block.stmt)} |
  {cst_break}      break           {-> New stmt.break()} |
  {cst_continue}   continue        {-> New stmt.continue()} |
  {cst_block}      cst_block       {-> cst_block.stmt}
  ;

cst_simple_stmt {-> stmt} =
  //{cst_empty}      /*empty*/           {-> New stmt.empty()} |
  //{cst_decl}       cst_top_decl        {-> New stmt.decl(cst_top_decl.decl)} |
  {cst_func_call}  function_call       {-> New stmt.exp(function_call.exp)} |
  {cst_increment}  lvalue plus_plus    {-> New stmt.increment(lvalue.exp)} |
  {cst_decrement}  lvalue minus_minus  {-> New stmt.decrement(lvalue.exp)} |
  {cst_assigassn}     cst_assign_stmt     {-> cst_assign_stmt.stmt};
  //{cst_short_decl} cst_short_decl_stmt {-> cst_short_decl_stmt.stmt};

cst_return_stmt {-> } =
  {cst_empty}  {-> } |
  {cst_exp}   cst_exp {-> };

cst_if_stmt {-> stmt} = 
  {cst_if} if cst_simple_stmt_if? cst_exp cst_block cst_end_if? {-> New stmt.if(cst_simple_stmt_if.stmt, cst_exp.exp, cst_block.stmt, cst_end_if.stmt)};

cst_simple_stmt_if {-> stmt} =
  {cst_empty} semicolon {-> New stmt.empty()} |
  {cst_simple_stmt} cst_simple_stmt_eol {-> cst_simple_stmt_eol.stmt}
  ; 

cst_end_if {-> stmt} =
  {cst_else_if} else cst_if_stmt {-> New stmt.else_if(cst_if_stmt.stmt)} |
  {cst_else}    else cst_block   {-> New stmt.else(cst_block.stmt)};

cst_exp {-> exp} =
  {cst_conj} cst_conj {-> cst_conj.exp} | 
  {cst_or} cst_exp logical_or cst_conj {-> New exp.logical_or(cst_exp.exp, cst_conj.exp)} 
  ;

cst_conj {-> exp} =
  {cst_cla} cst_cla {-> cst_cla.exp} |
  {and} cst_conj logical_and cst_cla {-> New exp.logical_and(cst_conj.exp, cst_cla.exp)} 
  ;

cst_cla {-> exp} =
  {cst_subex} cst_subex {-> cst_subex.exp} |
  {cst_eq} cst_cla equals_equals cst_subex {-> New exp.equals_equals(cst_cla.exp, cst_subex.exp)} | 
  {cst_neq} cst_cla exclamation_equals cst_subex {-> New exp.not_equal(cst_cla.exp, cst_subex.exp)} |
  {cst_lt} cst_cla less cst_subex {-> New exp.less(cst_cla.exp, cst_subex.exp)} |
  {cst_lte} cst_cla less_equals cst_subex {-> New exp.less_equals(cst_cla.exp, cst_subex.exp)} |
  {cst_gt} cst_cla greater cst_subex {-> New exp.greater(cst_cla.exp, cst_subex.exp)} |
  {cst_gte} cst_cla greater_equals cst_subex {-> New exp.greater_equals(cst_cla.exp, cst_subex.exp)} 
  ;

cst_subex {-> exp} =
  {factor} factor {-> factor.exp} |
  {plus} cst_subex plus factor {-> New exp.plus(cst_subex.exp, factor.exp)} |
  {minus} cst_subex minus factor {-> New exp.minus(cst_subex.exp, factor.exp)} |
  {bit_or} cst_subex pipe factor {-> New exp.pipe(cst_subex.exp, factor.exp)} |
  {bit_xor} cst_subex caret factor {-> New exp.caret(cst_subex.exp, factor.exp)} 
  ;

factor {-> exp} =
  {term} term {-> term.exp} |
  {mult} factor star term {-> New exp.mult(factor.exp, term.exp)} |
  {div} factor slash term {-> New exp.divide(factor.exp, term.exp)} |
  {mod} factor modulo term {-> New exp.modulo(factor.exp, term.exp)} |
  {bit_lshift} factor shift_left term {-> New exp.shift_left(factor.exp, term.exp)} |
  {bit_rshift} factor shift_right term {-> New exp.shift_right(factor.exp, term.exp)} |
  {bit_and} factor ampersand term {-> New exp.ampersand(factor.exp, term.exp)} |
  {bit_clear} factor ampersand_caret term {-> New exp.ampersand_caret(factor.exp, term.exp)} 
  ;

term {-> exp} =
  {atom} atom {-> atom.exp} |
  {plus} plus term {-> New exp.unary_plus(term.exp)} |
  {minus} minus term {-> New exp.unary_minus(term.exp)} |
  {negate} exclamation term {-> New exp.exclamated_factors(term.exp)} |
  {bit_comp} caret term {-> New exp.careted_factors(term.exp)} 
  ;

atom {-> exp} =
  {lit} lit {-> lit.exp} |
  {id} cst_id {-> New exp.id(cst_id.id_type)} |
  {field} field {-> field.exp} |
  {func_call} func_call {-> func_call.exp} |
  {array_elem} array_elem {-> array_elem.exp} |
  {paren} l_paren cst_exp r_paren {-> cst_exp.exp}
  ;

func_call {-> exp} =
  {append} append l_paren cst_id comma cst_exp r_paren {-> New exp.appended_expr(New exp.id(cst_id.id_type), cst_exp.exp)} |
  {custom} id l_paren cst_exp_list r_paren {-> New exp.empty()}//function_call_secondary(New exp.id(cst_id.id_type), [cst_exp_list.exp])} 
  ;

field {-> exp} = 
  atom dot cst_id {-> New exp.struct_selector(atom.exp, New exp.id(cst_id.id_type))} 
  ;

// Weeding verifies the array access is conducted on a "Array accessible".
array_elem {-> exp} = 
  atom l_brack cst_exp r_brack {-> New exp.array_index(atom.exp, cst_exp.exp)} 
  ;

//* Literals. *//

lit {-> exp} =
  {int} int {-> New exp.int(int)} |
  {oct} oct {-> New exp.oct(oct)} |
  {hex} hex {-> New exp.hex(hex)} |
  {float} float64_literal {-> New exp.float64_literal(float64_literal)} |
  {rune} rune_literal {-> New exp.rune_literal(rune_literal)} |
  {interpreted_string} interpreted_string_literal {-> New exp.interpreted_string_literal(interpreted_string_literal)} |
  {raw_string} raw_string_lit {-> New exp.raw_string_lit(raw_string_lit)}
  ;

/*cst_exp {-> exp} = 
  {term}     term {-> term.exp} |
  {unary_op}   unary_op {-> unary_op.exp} |
  {binary_op}  binary_op {-> binary_op.exp} |
  {function_call} function_call {-> function_call.exp} |
  {array_indexing} array_indexing {-> array_indexing.exp} |
  {cst_selection} cst_selection {-> cst_selection.exp} |
  {append_expr} append_expr {-> append_expr.exp};*/

cst_selection {-> exp} = 
  {cst_selection_first_term} term cst_selector+ {-> term.exp};

cst_selector {-> exp} =
  {cst_dot_term} dot term {-> term.exp};

array_indexing {-> exp} = 
  {array_to_be_indexed} term cst_index+ {-> New exp.array_indexing(term.exp, [cst_index.exp])};

cst_index {-> exp} =
  {end_recurse} l_brack cst_exp r_brack  {-> cst_exp.exp};

/*term {-> exp} =
  {cst_id}        cst_id {-> New exp.id(cst_id.id_type)} |
  {cst_float64}   float64_literal  {-> New exp.float64_literal(float64_literal)} |
  {cst_int}       int    {-> New exp.int(int)} |
  {cst_oct}       oct    {-> New exp.oct(oct)} |
  {cst_hex}       hex    {-> New exp.hex(hex)} |
  {cst_rune_literal} rune_literal {-> New exp.rune_literal(rune_literal)} |
  {cst_raw_string_lit} raw_string_lit {-> New exp.raw_string_lit(raw_string_lit)} |
  {cst_interpreted_string_literal} interpreted_string_literal {-> New exp.interpreted_string_literal(interpreted_string_literal)} |
  {paren}         l_paren cst_exp r_paren  {-> cst_exp.exp};*/

special_term {-> exp} =
  {array_indexing} array_indexing {-> array_indexing.exp}|
  {cst_selection} cst_selection {-> cst_selection.exp};

binary_op {-> exp} =
  {cst_plus} cst_exp plus term  {-> New exp.plus(cst_exp.exp,term.exp)} |
  {cst_plus_special_term} cst_exp plus special_term {-> New exp.plus(cst_exp.exp,special_term.exp)} |
  {cst_multiply_special_term} cst_exp star special_term {-> New exp.mult(cst_exp.exp, special_term.exp)} |
  {cst_multiply_factor} cst_exp star term {-> New exp.mult(cst_exp.exp, term.exp)} |
  {cst_divide} cst_exp slash term {-> New exp.divide(cst_exp.exp,term.exp)} |
  {cst_divide_special_term} cst_exp slash special_term {-> New exp.divide(cst_exp.exp,special_term.exp)} |
  {cst_minus} cst_exp minus term {-> New exp.minus(cst_exp.exp,term.exp)} | 
  {cst_minus_special_term} cst_exp minus special_term {-> New exp.minus(cst_exp.exp,special_term.exp)} |
  {cst_modulo} cst_exp modulo special_term {-> New exp.modulo(cst_exp.exp, special_term.exp)} |
  {cst_modulo_special_term} cst_exp modulo term {-> New exp.modulo(cst_exp.exp, term.exp)} |  
  {cst_ampersand} cst_exp ampersand term {-> New exp.ampersand(cst_exp.exp, term.exp)} |
  {cst_ampersand_special_term} cst_exp ampersand special_term {-> New exp.ampersand(cst_exp.exp, special_term.exp)} |
  {cst_ampersand_caret} cst_exp ampersand_caret term {-> New exp.ampersand_caret(cst_exp.exp, term.exp)} |
  {cst_ampersand_caret_special_term} cst_exp ampersand_caret special_term {-> New exp.ampersand_caret(cst_exp.exp, special_term.exp)} |
  {cst_shift_left} cst_exp shift_left term {-> New exp.shift_left(cst_exp.exp, term.exp)} |
  {cst_shift_left_special_term}  cst_exp shift_left special_term {-> New exp.shift_left(cst_exp.exp, special_term.exp)} |
  {cst_shift_right} cst_exp shift_right term {-> New exp.shift_right(cst_exp.exp, term.exp)} |
  {cst_shift_right_special_term} cst_exp shift_right special_term {-> New exp.shift_right(cst_exp.exp, special_term.exp)} |
  {cst_logical_or} cst_exp logical_or term {-> New exp.logical_or(cst_exp.exp, term.exp)} |
  {cst_logical_or_special_term} cst_exp logical_or special_term {-> New exp.logical_or(cst_exp.exp, special_term.exp)} |
  {cst_logical_and} cst_exp logical_and term {-> New exp.logical_and(cst_exp.exp, term.exp)} |
  {cst_logical_and_special_term} cst_exp logical_and special_term {-> New exp.logical_and(cst_exp.exp, special_term.exp)} |
  {cst_pipe} cst_exp pipe term {-> New exp.pipe(cst_exp.exp, term.exp)} |
  {cst_pipe_and_special_term} cst_exp pipe special_term {-> New exp.pipe(cst_exp.exp, special_term.exp)} |
  {cst_caret} cst_exp caret term {-> New exp.caret(cst_exp.exp, term.exp)} |
  {cst_caret_and_special_term} cst_exp caret special_term {-> New exp.caret(cst_exp.exp, special_term.exp)} |
  {cst_rel_op} rel_op {-> rel_op.exp};

rel_op {-> exp} = 
  {cst_equals_equals} cst_exp equals_equals term {-> New exp.equals_equals(cst_exp.exp, term.exp)} |
  {cst_equals_equals_special_term} cst_exp equals_equals special_term {-> New exp.equals_equals(cst_exp.exp, special_term.exp)} |
  {cst_not_equals} cst_exp exclamation_equals term {-> New exp.not_equal(cst_exp.exp, term.exp)} |
  {cst_not_equals_special_term} cst_exp exclamation_equals special_term {-> New exp.not_equal(cst_exp.exp, special_term.exp)} |
  {cst_less_than} cst_exp less term {-> New exp.less(cst_exp.exp, term.exp)} |
  {cst_less_than_special_term} cst_exp less special_term {-> New exp.less(cst_exp.exp, special_term.exp)} |
  {cst_greater_than} cst_exp greater term {-> New exp.greater(cst_exp.exp, term.exp)} |
  {cst_greater_than_special_term} cst_exp greater special_term {-> New exp.greater(cst_exp.exp, special_term.exp)} |
  {cst_less_than_equals} cst_exp less_equals term {-> New exp.less_equals(cst_exp.exp, term.exp)} |
  {cst_less_than_equals_special_term} cst_exp less_equals special_term {-> New exp.less_equals(cst_exp.exp, special_term.exp)} |
  {cst_greater_than_equals} cst_exp greater_equals term {-> New exp.greater_equals(cst_exp.exp, term.exp)} |
  {cst_greater_than_equals_special_term} cst_exp greater_equals special_term {-> New exp.greater_equals(cst_exp.exp, special_term.exp)};

unary_op {-> exp} = 
  {positive_expression} plus term { -> New exp.unary_plus(term.exp)} |
  {negative_expression} minus term {-> New exp.unary_minus(term.exp)} |
  {caret_expression} caret careted_factors {-> New exp.careted_factors(careted_factors.exp)} |
  {exclamation_exoression} exclamation exclamated_factors {-> New exp.exclamated_factors(exclamated_factors.exp)};

careted_factors {-> exp} = 
  {factor} term {-> term.exp} |
  {careted_factors} caret careted_factors { -> New exp.careted_factors(careted_factors.exp)};

exclamated_factors {-> exp} = 
  {factor} term {-> term.exp} |
  {exclamated_factors} exclamation exclamated_factors {-> New exp.exclamated_factors(exclamated_factors.exp)};

function_call {-> exp} =
  {empty_args}  term l_paren r_paren {-> New exp.function_call_secondary(term.exp, [])} |
  {one_or_more_args} term l_paren cst_exp_list r_paren {-> New exp.function_call_secondary(term.exp, [cst_exp_list.exp])};
  
append_expr {-> exp} =
  append l_paren cst_exp comma other_exp r_paren { -> New exp.appended_expr(cst_exp.exp, other_exp.exp)};

other_exp {-> exp} =
  cst_exp { -> cst_exp.exp};

cst_block {-> stmt} =
  {cst_block} l_brace semicolon cst_stmt_list r_brace {-> New stmt.block([cst_stmt_list.stmt])};

cst_stmt_list {-> stmt*} =
  {cst_stmt_list} cst_stmt_eos* {-> [cst_stmt_eos.stmt]};

cst_stmt_eos {-> stmt} =    
  {cst_stmt_eos}  cst_stmt cst_eos {-> cst_stmt.stmt}; // Add eos

cst_eos {-> stmt} =
  {cst_semicolon} semicolon    {-> New stmt.empty()} |
  {cst_eof}       end_of_file  {-> New stmt.empty()};

cst_switch_stmt {-> stmt} =
  {cst_switch} switch cst_simple_stmt_eol? cst_exp? l_brace semicolon cst_switch_case_clause* r_brace {-> New stmt.switch(cst_simple_stmt_eol.stmt, cst_exp.exp, [cst_switch_case_clause.stmt])};

cst_simple_stmt_eol {-> stmt} =
  {cst_simple_eol} cst_simple_stmt semicolon {-> cst_simple_stmt.stmt};

cst_switch_case_clause {-> stmt} =
  {cst_case_clause} cst_switch_case colon cst_stmt_list {-> New stmt.case(cst_switch_case.exp, [cst_stmt_list.stmt])};

cst_switch_case {-> exp} =
  {cst_case}   case cst_exp_list {-> New exp.case([cst_exp_list.exp])} |
  {cst_switch} default {-> New exp.default()}; 

cst_for_condition {-> exp} =
  {cst_empty}    /* empty */ {-> New exp.empty()} |
  {cst_exp}      cst_exp {-> cst_exp.exp} |
  {cst_clause}   [l]:cst_simple_stmt? [sl]:semicolon cst_exp? [sr]:semicolon [r]:cst_simple_stmt? {-> New exp.for_cond(l.stmt, cst_exp.exp, r.stmt)};

cst_assign_stmt {-> stmt} =
  {cst_assign_stmt}   lvalue_list list_equals cst_exp_list {-> New stmt.assign_list([lvalue_list.exp], list_equals.exp, [cst_exp_list.exp])};

lvalue_list {-> exp+} =
  {cst_lvalue}      lvalue     {-> [lvalue.exp]} |
  {cst_lvalue_list} lvalue_list comma lvalue {-> [lvalue_list.exp,lvalue.exp]};

list_equals {-> exp} =
  {cst_equals}       equals        {-> New exp.equals()} |
  {cst_colon_equals} colon_equals  {-> New exp.colon_equals()} |
  {cst_op_equals}    op_equals     {-> New exp.op_equals(op_equals)};

cst_id_comma {-> id} =
  {cst_id_comman} id comma {-> id};

cst_exp_list {-> exp*} =
  {cst_exp}      cst_exp     {-> [cst_exp.exp]} |
  {cst_exp_list} cst_exp_list comma cst_exp {-> [cst_exp_list.exp, cst_exp.exp]};

lvalue {-> exp} =
  {id} cst_exp {-> cst_exp.exp};

//lvalue_no_id {-> exp} =
//  {cst_index}      id cst_index     {-> New exp.array_index(New exp.id(id), cst_index.exp)} |
//  {cst_selector}   id cst_selector  {-> New exp.struct_selector(New exp.id(id), cst_selector.exp)} |
//  {cst_lvalue_index}    lvalue_no_id cst_index    {-> New exp.array_index(lvalue_no_id.exp, cst_index.exp)} |
//  {cst_lvalue_selector} lvalue_no_id dot id {-> New exp.struct_selector(lvalue_no_id.exp, New exp.id(id))};

//cst_selector {-> exp} =
//  {cst_selector} dot cst_exp {-> cst_exp.exp};

lvalue_id {-> exp} =
  {cst_id}      cst_id     {-> New exp.id(cst_id.id_type)} |
  {array_index} lvalue_id cst_index {-> New exp.array_index(lvalue_id.exp, cst_index.exp)} |
  {struct_selector}  lvalue_id dot cst_id {-> New exp.struct_selector(lvalue_id.exp, New exp.id(cst_id.id_type))};

lvalue_id_list {-> exp+} =
  {cst_lvalue}      lvalue_id     {-> [lvalue_id.exp]} |
  {cst_lvalue_list} lvalue_id_list comma lvalue_id {-> [lvalue_id_list.exp,lvalue_id.exp]};

Abstract Syntax Tree

program = package_decl decl*;

decl = 
  {pack_decl_ast} package_decl |
  {func_decl_ast} func_decl |
  {var_decl_ast} var_decl |
  {type_decl_ast} type_decl
  ;

package_decl = 
  id_type
  ;

func_decl = 
  {no_return} id_type signature? [block]:stmt |
  {single_return} id_type signature? var_type [block]:stmt  |
  ;

signature = 
  {multiple_types} [id_list]:id_type* var_type signature |
  {single_type}    [id_list]:id_type* var_type |
  ;

type_decl = 
  {type_alias} id_type var_type |
  //{type_with_many_ids} id_type type_decl |
  {struct_with_id} id_type type_decl* |
  {multiline_list} type_decl* |
  {struct_var_decl} [id_list]:id_type* var_type
  ;

var_decl = 
  {var_with_type} id_type var_type |
  {var_with_only_exp} id_type exp |
  {var_with_type_and_exp} id_type var_type exp |
  {inline_list_no_exp} id_type var_decl |
  {inline_list_with_exp} id_type var_decl exp |
  {multiline_list} var_decl* 
  ;

var_type = 
  {base_type} type |
  {slice} var_type |
  {array} int var_type |
  {struct} id
  ;

id_type = 
  {id} id |
  {type} type
  ;

stmt =
  {print}           exp* |
  {println}         exp* |
  {exp}             exp  |
  {return}          exp? |
  {increment}       exp  |
  {decrement}       exp  |
  {decl}            decl |
  {assign_list}     [l]:exp+ [op]:exp [r]:exp+ |
  {block}           stmt* |
  {if}              [simple_stmt]:stmt? exp [block]:stmt [end]:stmt?  |
  {else_if}         stmt |
  {else}            stmt |
  {for}             [condition]:exp [block]:stmt |
  {switch}          [simple_stmt]:stmt? exp? [case_stmts]:stmt* |
  {case}            [case_exp]:exp  [stmt_list]:stmt+ |
  {break}     |
  {continue}  | 
  {empty};

exp =
  {plus}   [l]:exp [r]:exp |
  {minus}  [l]:exp [r]:exp |
  {mult}   [l]:exp [r]:exp |
  {divide} [l]:exp [r]:exp |
  {modulo} [l]:exp [r]:exp |
  {ampersand} [l]:exp [r]:exp |
  {ampersand_caret} [l]:exp [r]:exp |
  {shift_left} [l]:exp [r]:exp |
  {shift_right} [l]:exp [r]:exp |
  {logical_or} [l]:exp [r]:exp |
  {logical_and} [l]:exp [r]:exp |
  {equals_equals} [l]:exp [r]:exp |
  {not_equal} [l]:exp [r]:exp |
  {less} [l]:exp [r]:exp |
  {less_equals} [l]:exp [r]:exp |
  {greater_equals} [l]:exp [r]:exp |
  {greater} [l]:exp [r]:exp |
  {pipe} [l]:exp [r]:exp |
  {caret} [l]:exp [r]:exp |
  {id} id_type |
  {float64_literal} float64_literal |
  {int} int |
  {oct} oct |
  {hex} hex |
  {unary_plus} exp |
  {unary_minus} exp |
  {unary_xor} exp |
  {unary_exclamation} exp |
  {rune_literal} rune_literal |
  {raw_string_lit} raw_string_lit |
  {interpreted_string_literal} interpreted_string_literal |
  {function_call_secondary} exp [exp_list]:exp* |
  {array_indexing} exp [exp_list]:exp* |
  {array_index} [lvalue]:exp [index]:exp | 
  {appended_expr} [l]:exp [r]:exp |
  {struct_selector}  [l]:exp [r]:exp |
  {for_cond}  [first]:stmt? [second]:exp? [third]:stmt? |
  {case}      [exp_list]:exp* |
  {default} |
  {careted_factors} exp |
  {exclamated_factors} exp |
  //{lvalue_list} exp+ |
  {equals} |
  {colon_equals} |
  {op_equals} op_equals |
  {empty};
