Package golite;

Helpers
  all_chars = [0..0xffff];
  all_chars_but_linefeed = [all_chars-10];
  all_chars_but_star_slash = [[all_chars-'*']-'/'];
  star_without_slash = '*' [all_chars - '/'];
  tab = 9;
  line_feed = 10;
  carriage_return = 13;
  space = ' ';
  digit = ['0'..'9'];
  positive_digit = ['1'..'9'];
  integer = '0' | (positive_digit digit*);
  float_decimal = '.' digit*;
  letter = ['a'..'z'] | ['A'..'Z'];
  string_symbols = letter | digit | ':' | ':' | '~' | '#' | '$' | '%' | '^' | '&' | '*' | '-' | '+' | '/' | '`' | ''' | '<' | '>' | '=' | '_' | '|' | ';' | ':' | '{' | '}' | '[' | ']' | '(' | ')' | space | '@' | '!' | '?' | '.' | ',';
  escape_single_quote = '\' ''';
  escape_double_quote = '\"';
  escape_sequences = '\a' | '\b' | '\f' | '\n' | '\r' | '\t' | '\v' | '\\' | escape_single_quote;
  oct_digit = ['0' .. '7'] ;
  hex_digit = digit | ['A' .. 'F'] | ['a' .. 'f'] ;
  single_quote = ''' ;
  double_quote = '"' ;
  back_quote = '`' ;
  not_end_of_line = [all_chars - [carriage_return + line_feed]] ;

Tokens
  break = 'break';
  case = 'case';
  chan = 'chan';
  const = 'const';
  continue = 'continue';
  default = 'default';
  defer = 'defer';
  fallthrough = 'fallthrough';
  for = 'for';
  func = 'func';
  go = 'go';
  goto = 'goto';
  var = 'var';
  import = 'import';
  interface = 'interface';
  map = 'map';
  package = 'package';
  range = 'range';
  return = 'return';
  select = 'select';
  struct = 'struct';
  switch = 'switch';
  type = 'float64'|'rune'|'int'|'bool'|'string';
  type_keyword = 'type';
  plus = '+';
  minus = '-';
  star = '*';
  slash = '/';
  modulo = '%';
  ampersand = '&';
  pipe = '|';
  caret = '^';
  shift_left = '<<';
  shift_right = '>>';
  ampersand_caret = '&^';
  plus_equals = '+=';
  minus_equals = '-=';
  times_equals = '*=';
  slash_equals = '/=';
  modulo_equals = '%=';
  ampersand_equals = '&=';
  pipe_equals = '|=';
  caret_equals = '^=';
  shift_left_equals = '<<=';
  shift_right_equals = '>>=';
  ampersand_caret_equals = '&^=';
  logical_and = '&&';
  logical_or = '||';
  left_arrow = '<-';
  plus_plus = '++';
  minus_minus = '--';
  equals_equals = '==';
  less = '<';
  greater = '>';
  equals = '=';
  exclamation = '!';
  exclamation_equals = '!=';
  less_equals = '<=';
  greater_equals = '>=';
  colon_equals = ':=';
  dot_dot_dot = '...';
  l_paren = '(';
  r_paren = ')';
  l_brack = '[';
  r_brack = ']';
  l_brace = '{';
  r_brace = '}';
  comma = ',';
  semicolon = ';';
  colon = ':';
  dot = '.';
  print = 'print';
  println = 'println';
  append = 'append';
  comment = '//' all_chars_but_linefeed*;
  block_comment = '/*' (all_chars_but_star_slash | '/*' | star_without_slash)* '*/';
  int = integer;
  oct = '0' oct_digit+ ;
  hex = '0' ['x' + 'X'] hex_digit+;
  float64_literal = digit* '.' digit* | '.' digit+ ;
  float64 = 'float64';
  bool = 'bool';
  rune = 'rune';
  rune_literal = single_quote ([not_end_of_line - [single_quote + '\']] | escape_single_quote | escape_sequences) single_quote ;
  raw_string_lit = back_quote [all_chars - back_quote]* back_quote ;
  interpreted_string_literal = double_quote ([not_end_of_line - [double_quote + '\']] | escape_double_quote| escape_sequences)* double_quote ;
  id = (letter | '_')(letter | digit | '_')*;
  if = 'if';
  else = 'else';
  eol = line_feed | carriage_return | carriage_return line_feed;
  blank = tab | space;

Ignored Tokens
  eol, blank, comment, block_comment;

Productions
cst_prog {-> program} =
  {prog}    cst_top_decl* cst_stmt*   {-> New program([cst_top_decl.decl], [cst_stmt.stmt])}; 


cst_top_decl {-> decl} =
  {var_decl} cst_var_decl {-> New decl.var_decl_ast(cst_var_decl.var_decl)} 
  ;

cst_var_decl {-> var_decl} =
  {cst_single_line_decl} var top_var_decl {-> top_var_decl.var_decl} |
  {cst_multi_line_decl} var l_paren top_var_decl* r_paren semicolon {-> New var_decl.multiline_list([top_var_decl.var_decl])}
  ;

top_var_decl {-> var_decl} = 
  {cst_miat} id_and_type semicolon {-> id_and_type.var_decl} |
  {cst_miae} id_and_exp_maybe_type semicolon {-> id_and_exp_maybe_type.var_decl}
  ;

id_and_type {-> var_decl} = 
  {miat_recurse} id comma id_and_type {-> New var_decl.inline_list_no_exp(id, id_and_type.var_decl)} |
  {miat_end} id cst_type {-> New var_decl.var_with_type(id, cst_type.var_type)}
  ;

id_and_exp_maybe_type {-> var_decl} = 
  {miae_recurse} id [l]:comma id_and_exp_maybe_type [r]:comma cst_exp {-> New var_decl.inline_list_with_exp(id, id_and_exp_maybe_type.var_decl, cst_exp.exp)} |
  {miae_end} id equals cst_exp {-> New var_decl.var_with_only_exp(id, cst_exp.exp)} |
  {mtae_end} id cst_type equals cst_exp {-> New var_decl.var_with_type_and_exp(id, cst_type.var_type, cst_exp.exp)}
  ;

//structs is just an id when declaring since no inline constructions
cst_type {-> var_type} = 
  {cst_base_type} type {-> New var_type.base_type(type)}|
  {cst_slices} l_brack r_brack cst_type {-> New var_type.slice(cst_type.var_type)} | 
  {cst_arrays} l_brack int r_brack cst_type {-> New var_type.array(cst_type.var_type)}|
  {cst_structs} id {-> New var_type.struct(id)}
  ;

cst_stmt {-> stmt} =
  {cst_print}  print cst_exp semicolon {-> New stmt.print(cst_exp.exp)} |
  {cst_assign} id equals cst_exp semicolon {-> New stmt.assign(id, cst_exp.exp)}; 

cst_exp {-> exp} = 
  {factor}     factor {-> factor.exp} |
  {unary_op}   unary_op {-> unary_op.exp} |
  {binary_op}  binary_op {-> binary_op.exp} |
  {function_call} function_call {-> function_call.exp} |
  {append_expr} append_expr {-> append_expr.exp};

function_call {-> exp} =
  {empty_args} id l_paren r_paren {-> New exp.function_call(id)} |
  {one_or_more_args} id l_paren cst_exp input_arg_list* r_paren {-> New exp.function_call(id)};

input_arg_list =
  {multiple_args} comma cst_exp;
  
append_expr {-> exp} =
  append l_paren cst_exp comma other_exp r_paren { -> New exp.appended_expr(cst_exp.exp, other_exp.exp)};

other_exp {-> exp} =
  cst_exp { -> cst_exp.exp};

binary_op {-> exp} =
  {cst_plus}   cst_exp plus factor  {-> New exp.plus(cst_exp.exp,factor.exp)} |
  {cst_minus}  cst_exp minus factor {-> New exp.minus(cst_exp.exp,factor.exp)} | 
  {cst_logical_or} cst_exp logical_or factor {-> New exp.logical_or(cst_exp.exp, factor.exp)} |
  {cst_logical_and} cst_exp logical_and factor {-> New exp.logical_and(cst_exp.exp, factor.exp)} |
  {cst_pipe} cst_exp pipe factor {-> New exp.pipe(cst_exp.exp, factor.exp)} |
  {cst_caret} cst_exp caret factor {-> New exp.caret(cst_exp.exp, factor.exp)} |
  {cst_rel_op} rel_op {-> rel_op.exp};

rel_op {-> exp} = 
  {cst_equals_equals} cst_exp equals_equals factor {-> New exp.equals_equals(cst_exp.exp, factor.exp)} |
  {cst_not_equals} cst_exp exclamation_equals factor {-> New exp.not_equal(cst_exp.exp, factor.exp)} |
  {cst_less_than} cst_exp less factor {-> New exp.less(cst_exp.exp, factor.exp)} |
  {cst_greater_than} cst_exp greater factor {-> New exp.greater(cst_exp.exp, factor.exp)} |
  {cst_less_than_equals} cst_exp less_equals factor {-> New exp.less_equals(cst_exp.exp, factor.exp)} |
  {cst_greater_than_equals} cst_exp greater_equals factor {-> New exp.greater_equals(cst_exp.exp, factor.exp)};

unary_op {-> exp} = 
  {positive_expression} plus factor { -> New exp.unary_plus(factor.exp)} |
  {negative_expression} minus factor {-> New exp.unary_minus(factor.exp)} |
  {caret_expression} caret factor {-> New exp.unary_xor(factor.exp)} |
  {exclamation_exoression} exclamation factor {-> New exp.unary_exclamation(factor.exp)};


factor {-> exp} = 
  {cst_times}       factor star term  {-> New exp.mult(factor.exp,term.exp)} |
  {cst_divide}      factor slash term {-> New exp.divide(factor.exp,term.exp)} |
  {cst_modulo}      factor modulo term {-> New exp.modulo(factor.exp, term.exp)} |
  {cst_shift_left}  factor shift_left term {-> New exp.shift_left(factor.exp, term.exp)} |
  {cst_shift_right} factor shift_right term {-> New exp.shift_right(factor.exp, term.exp)} |
  {cst_ampersand}   factor ampersand term {-> New exp.ampersand(factor.exp, term.exp)} |
  {cst_ampersand_caret} factor ampersand_caret term {-> New exp.ampersand_caret(factor.exp, term.exp)} |
  {term}            term              {-> term.exp};

term {-> exp} =
  {cst_id}        id     {-> New exp.id(id)} |
  {cst_float64}   float64_literal  {-> New exp.float64_literal(float64_literal)} |
  {cst_int}       int    {-> New exp.int(int)} |
  {cst_rune_literal} rune_literal {-> New exp.rune_literal(rune_literal)} |
  {cst_raw_string_lit} raw_string_lit {-> New exp.raw_string_lit(raw_string_lit)} |
  {cst_interpreted_string_literal} interpreted_string_literal {-> New exp.interpreted_string_literal(interpreted_string_literal)} |
  {paren}         l_paren cst_exp r_paren  {-> cst_exp.exp};

Abstract Syntax Tree

program = decl* stmt*;

decl = 
  {var_decl_ast} var_decl
  ;

type_decl = 
  ;

var_decl = 
  {var_with_type} id var_type |
  {var_with_only_exp} id exp |
  {var_with_type_and_exp} id var_type exp |
  {inline_list_no_exp} id var_decl |
  {inline_list_with_exp} id var_decl exp |
  {multiline_list} var_decl*
  ;

var_type = 
  {base_type} type |
  {slice} var_type |
  {array} var_type |
  {struct} id
  ;

stmt =
  {read}      id |
  {print}     exp |
  {assign}    id exp |
  {while}     exp stmt* |
  {if}        exp [stmt]:stmt* [end]:stmt |
  {else}      stmt* |
  {empty};

exp =
  {plus}   [l]:exp [r]:exp |
  {minus}  [l]:exp [r]:exp |
  {mult}   [l]:exp [r]:exp |
  {divide} [l]:exp [r]:exp |
  {modulo} [l]:exp [r]:exp |
  {ampersand} [l]:exp [r]:exp |
  {ampersand_caret} [l]:exp [r]:exp |
  {shift_left} [l]:exp [r]:exp |
  {shift_right} [l]:exp [r]:exp |
  {logical_or} [l]:exp [r]:exp |
  {logical_and} [l]:exp [r]:exp |
  {equals_equals} [l]:exp [r]:exp |
  {not_equal} [l]:exp [r]:exp |
  {less} [l]:exp [r]:exp |
  {less_equals} [l]:exp [r]:exp |
  {greater_equals} [l]:exp [r]:exp |
  {greater} [l]:exp [r]:exp |
  {pipe} [l]:exp [r]:exp |
  {caret} [l]:exp [r]:exp |
  {id} id |
  {float64_literal} float64_literal |
  {int} int |
  {unary_plus} exp |
  {unary_minus} exp |
  {unary_xor} exp |
  {unary_exclamation} exp |
  {rune_literal} rune_literal |
  {raw_string_lit} raw_string_lit |
  {interpreted_string_literal} interpreted_string_literal |
  {function_call} id|
  {appended_expr} [l]:exp [r]:exp;