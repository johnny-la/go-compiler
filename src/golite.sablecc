Package golite;

Helpers
  all_chars = [0..0xffff];
  all_chars_but_linefeed = [all_chars-10];
  all_chars_but_star_slash = [[all_chars-'*']-'/'];
  star_without_slash = '*' [all_chars - '/'];
  tab = 9;
  line_feed = 10;
  carriage_return = 13;
  space = ' ';
  digit = ['0'..'9'];
  positive_digit = ['1'..'9'];
  integer = '0' | (positive_digit digit*);
  float_decimal = '.' digit*;
  letter = ['a'..'z'] | ['A'..'Z'];
  string_symbols = letter | digit | ':' | ':' | '~' | '#' | '$' | '%' | '^' | '&' | '*' | '-' | '+' | '/' | '`' | ''' | '<' | '>' | '=' | '_' | '|' | ';' | ':' | '{' | '}' | '[' | ']' | '(' | ')' | space | '@' | '!' | '?' | '.' | ',';
  escape_single_quote = '\' ''';
  escape_double_quote = '\"';
  escape_sequences = '\a' | '\b' | '\f' | '\n' | '\r' | '\t' | '\v' | '\\' | escape_single_quote;
  oct_digit = ['0' .. '7'] ;
  hex_digit = digit | ['A' .. 'F'] | ['a' .. 'f'] ;
  single_quote = ''' ;
  double_quote = '"' ;
  back_quote = '`' ;
  not_end_of_line = [all_chars - [carriage_return + line_feed]] ;

Tokens
  break = 'break';
  case = 'case';
  chan = 'chan';
  const = 'const';
  continue = 'continue';
  default = 'default';
  defer = 'defer';
  fallthrough = 'fallthrough';
  for = 'for';
  func = 'func';
  go = 'go';
  goto = 'goto';
  import = 'import';
  interface = 'interface';
  map = 'map';
  package = 'package';
  range = 'range';
  return = 'return';
  select = 'select';
  struct = 'struct';
  switch = 'switch';
  type = 'type';
  op_equals = ('+' | '&' | '&^' | '-' | '|' | '<' | '*' | '^' | '/' | '<<' | '%' | '>>')
 '=';
  plus = '+';
  minus = '-';
  star = '*';
  slash = '/';
  modulo = '%';
  ampersand = '&';
  pipe = '|';
  caret = '^';
  shift_left = '<<';
  shift_right = '>>';
  ampersand_caret = '&^';
  logical_and = '&&';
  logical_or = '||';
  left_arrow = '<-';
  plus_plus = '++';
  minus_minus = '--';
  equals_equals = '==';
  less = '<';
  greater = '>';
  equals = '=';
  exclamation = '!';
  exclamation_equals = '!=';
  less_equals = '<=';
  greater_equals = '>=';
  colon_equals = ':=';
  dot_dot_dot = '...';
  l_paren = '(';
  r_paren = ')';
  l_brack = '[';
  r_brack = ']';
  l_brace = '{';
  r_brace = '}';
  comma = ',';
  semicolon = ';';
  colon = ':';
  dot = '.';
  print = 'print';
  println = 'println';
  append = 'append';
  comment = '//' all_chars_but_linefeed*;
  block_comment = '/*' (all_chars_but_star_slash | '/*' | star_without_slash)* '*/';
  int = integer;
  oct = '0' oct_digit+ ;
  hex = '0' ['x' + 'X'] hex_digit+;
  float = digit* '.' digit* | '.' digit+ ;
  float64 = 'float64';
  bool = 'bool';
  rune = 'rune';
  rune_literal = single_quote ([not_end_of_line - [single_quote + '\']] | escape_single_quote | escape_sequences) single_quote ;
  raw_string_lit = back_quote [all_chars - back_quote]* back_quote ;
  interpreted_string_literal = double_quote ([not_end_of_line - [double_quote + '\']] | escape_double_quote| escape_sequences)* double_quote ;
  id = (letter | '_')(letter | digit | '_')*;
  var = 'var';
  if = 'if';
  else = 'else';
  eol = line_feed | carriage_return | carriage_return line_feed;
  blank = tab | space;

Ignored Tokens
  eol, blank, comment, block_comment;

Productions
cst_prog {-> program} =
  {prog}    cst_decl* cst_stmt*   {-> New program([cst_decl.decl], [cst_stmt.stmt])}; 

cst_decl {-> decl} =
  {decl_var}   var id colon type semicolon {-> New decl.var(id,type)};

cst_stmt {-> stmt} =
  {cst_assign}     cst_assign_stmt     {-> cst_assign_stmt.stmt} |
  {cst_short_decl} cst_short_decl_stmt {-> cst_short_decl_stmt.stmt} |
  {cst_increment}  lvalue plus_plus    {-> New stmt.increment(lvalue.exp)} |
  {cst_decrement}  lvalue minus_minus  {-> New stmt.decrement(lvalue.exp)} |
  {cst_print}  print cst_exp semicolon {-> New stmt.print(cst_exp.exp)};
  //{cst_assign} id equals cst_exp semicolon {-> New stmt.assign(id, cst_exp.exp)}; 

cst_assign_stmt {-> stmt} =
  {cst_assign_stmt} lvalue op_equals cst_exp {-> New stmt.assign_op(lvalue.exp,op_equals,cst_exp.exp)} |
  {cst_assign_op_stmt} cst_assign_op_stmt {-> cst_assign_op_stmt.stmt};

cst_assign_op_stmt {-> stmt} =
  {lvalue_assign} lvalue equals cst_exp {-> New stmt.assign(lvalue.exp, cst_exp.exp)} |
  {lvalue_assign_list} lvalue [l]:comma cst_assign_op_stmt [r]:comma cst_exp {-> New stmt.assign_list(lvalue.exp, cst_assign_op_stmt.stmt, cst_exp.exp)};

cst_short_decl_stmt {-> stmt} =
  {cst_short_decl} id colon_equals cst_exp {-> New stmt.short_decl(id, cst_exp.exp)};
  //{cst_short_decl_list} cst_id_comma cst_short_decl_stmt [r]:comma cst_exp {-> New stmt.short_decl_list(cst_id_comma.id, cst_short_decl_stmt.stmt, cst_exp.exp)};

cst_id_comma {-> id} =
  {cst_id_comman} id comma {-> id};

cst_exp {-> exp} =
  {cst_plus}   cst_exp plus factor  {-> New exp.plus(cst_exp.exp,factor.exp)} |
  {cst_minus}  cst_exp minus factor {-> New exp.minus(cst_exp.exp,factor.exp)} | 
  {factor}     factor {-> factor.exp};

factor {-> exp} = 
  {cst_times}      factor star uterm  {-> New exp.mult(factor.exp,uterm.exp)} |
  {cst_divide}     factor slash uterm {-> New exp.divide(factor.exp,uterm.exp)} |
  {uterm}          uterm              {-> uterm.exp};

uterm {-> exp} =
  {cst_uminus}  minus uterm   {-> New exp.uminus(uterm.exp)} |
  {term}        term          {-> term.exp};

term {-> exp} =
  {cst_id}        id     {-> New exp.id(id)} |
  {cst_float}     float  {-> New exp.float(float)} |
  {cst_int}       int    {-> New exp.int(int)} |
  {paren}         l_paren cst_exp r_paren  {-> cst_exp.exp};

lvalue {-> exp} =
  {cst_id}      id     {-> New exp.id(id)} |
  {array_index} lvalue cst_index {-> New exp.array_index(lvalue.exp, cst_index.exp)} |
  {struct_selector}  lvalue cst_selector  {-> New exp.struct_selector(lvalue.exp, cst_selector.exp)};

cst_index {-> exp} =
  {cst_index} l_brack cst_exp r_brack {-> cst_exp.exp};

cst_selector {-> exp} =
  {cst_selector} dot cst_exp {-> cst_exp.exp};

Abstract Syntax Tree
program = decl* stmt*;

decl =
  {var}       id type;

stmt =
  {read}            id |
  {print}           exp |
  {increment}       exp |
  {decrement}       exp |
  {assign}          [l]:exp [r]:exp |
  {assign_op}       [l]:exp op_equals [r]:exp |
  {assign_list}     [l]:exp stmt [r]:exp |
  {short_decl}      id exp |
  {short_decl_list} id stmt exp |
  {while}           exp stmt* |
  {if}              exp [stmt]:stmt* [end]:stmt |
  {else}            stmt* |
  {empty};

exp =
  {plus}      [l]:exp [r]:exp |
  {minus}     [l]:exp [r]:exp |
  {mult}      [l]:exp [r]:exp |
  {divide}    [l]:exp [r]:exp |
  {uminus}    exp |
  {array_index}      [lvalue]:exp [index]:exp |
  {struct_selector}  [l]:exp [r]:exp |
  {id} id |
  {float} float |
  {int} int;

